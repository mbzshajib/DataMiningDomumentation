In this section we have provided experiment analysis. In the experiment we have focused on (1) correctness of our proposed algorithm and (2) the comparison with existing algorithm SUF-growth ~\cite{suf_growth}. For the extensive experiment we have choose mushroom dataset  and T40I10D100K database. The reason we have choose these two dataset is, mushroom  is real life dataset and dense dataset whereas T40I10D100K  is synthetic and sparse dataset generated by a generator from the IBM Almaden Quest. Table \ref{table:dataset} shows the details the properties for dataset . Later we have also took chess  for comparison with algorithm. The experimental results have been given in the following subsections.
\subsection{Algorithm Performance Analysis}
	\paragraph{Total Database Size Change Effect}Our experiment shows clearly that our proposed tree construction algorithm \emph{US-tree}, tree mining algorithm \emph{USFP-growth} works nicely with any size of window, batch or transaction size. For Different size of database (transaction count in a tree) this algorithm works extensively. Figure \ref{result:g_m_const_tran} shows the total running time (includes tree construction, mining and false positive reduction) change with the growth of size of mushroom dataset . Figure \ref{result:g_t10_const_tran} the same characteristic for T40I10D100K dataset . Figure \ref{result:g_m_const_tran_mem} and figure \ref{result:g_t10_const_tran_mem} shows the total nodes change in a tree while the size of database grows for databases corresponding to mushroom and T40I10D100K database. The growth of the graphs is very much regular. From these graphs it is clearly visible that, with the growth of total transaction the time increases and this certainly proves the scalability of our algorithm. 
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\begin{figure}[h]
		\centering
			\input{result/mushroom/g_m_const_tran}
		\caption{Size of Database vs Running Time for Mushroom Dataset }
		\label{result:g_m_const_tran}
		\end{figure}
		\begin{figure}[h]
		\centering
			\input{result/t10/g_t10_const_tran}
		\caption{Size of Database vs Running Time for T40I10D100K Dataset }
		\label{result:g_t10_const_tran}
		\end{figure}
%		\begin{figure}[h]
%		\centering
%			\input{result/kosarak/g_k_const_tran}
%		\caption{Size of Database vs Running Time for Kosarak Dataset }
%		\label{result:g_k_const_tran}
%		\end{figure}
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\begin{figure}[h]
		\centering
			\input{result/mushroom/g_m_const_tran_mem}
		\caption{Size of Database vs Total Nodes in Tree for Mushroom Dataset }
		\label{result:g_m_const_tran_mem}
		\end{figure}
		\begin{figure}[h]
		\centering
			\input{result/t10/g_t10_const_tran_mem}
		\caption{Size of Database vs Total Nodes in Tree for T40I10D100K Dataset }
		\label{result:g_t10_const_tran_mem}
		\end{figure}
%		\begin{figure}[h]
%		\centering
%			\input{result/kosarak/g_k_const_tran_mem}
%		\caption{Size of Database vs Total Nodes in Tree for Kosarak Dataset }
%		\label{result:g_k_const_tran_mem}
%		\end{figure}
%		
	\paragraph{Window Size Change Effect}For window size change effect we have experiment our algorithm in different angle. Experiment shows the window size change effect do not hamper performance and it is consistent. Figure \ref{result:g_m_const_batch} and figure \ref{result:g_t10_const_batch} shows effect of window size change effect on mushroom and T40I10D100K dataset.
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\begin{figure}[h]
		\centering
			\input{result/mushroom/g_m_const_batch}
		\caption{Batch Size vs Running Time for Mushroom Dataset }
		\label{result:g_m_const_batch}
		\end{figure}
		\begin{figure}[h]
		\centering
			\input{result/t10/g_t10_const_batch}
		\caption{Batch Size vs Running Time for T40I10D100K Dataset }
		\label{result:g_t10_const_batch}
		\end{figure}
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		
	\paragraph{Batch Size Change Effect}Like batch change effect we also experimented for batch size change effect.For changing batch size in different volume the result we find is consistent. For constant window and variable batches we have simulated our proposed algorithms. Figure \ref{result:g_m_const_batch} and figure \ref{result:g_t10_const_batch} shows effect of batch size change effect on mushroom and T40I10D100K dataset.
		\begin{figure}[h]
		\centering
			\input{result/mushroom/g_m_const_win}
		\caption{Window Size vs Running Time for Mushroom Dataset }
		\label{result:g_m_const_win}
		\end{figure}
		\begin{figure}[h]
		\centering
			\input{result/t10/g_t10_const_win}
		\caption{Window Size vs Running Time for T40I10D100K Dataset }
		\label{result:g_t10_const_win}
		\end{figure}
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		
\subsection{Comparison With Existing Approaches}
Here now we have compared our proposed approach with existing system. We have choose SUF-growth ~\cite{suf_growth}  for comparison. This algorithm is perfectly fit for uncertain stream data mining. UF-streaming also designed for mining frequent patterns from uncertain stream but in ~\cite{suf_growth} it has been proved that in all criteria (running time, memory and correctness) SUF-growth ~\cite{suf_growth} is better than UF-streaming ~\cite{suf_growth}. We have experimented for both running time performance and memory efficiency. The result has described below:
	\subsubsection{Running Time Comparison}
	Run time comparison has been experimented and the in the result we found is consistent and we have gained run time efficiency for both dense and sparse dataset. For mushroom dataset our approach's total tree construction time , total mining time and total time has been compared with SUF-growth ~\cite{suf_growth}'s tree construction time and mining time and total time. Figure \ref{result:g_m_tree_construction_total}, figure \ref{result:g_m_mining_total} and figure \ref{result:g_m_total} shows the result graph. As mushroom is a dense database we gain much more in run time. For dense characteristic the constructed \emph{US-tree} is very much compact and more over when mining compact tree the mining time surprisingly decreases that effect the total time. Figure \ref{result:g_t10_tree_construction_total}, figure \ref{result:g_t10_mining_total} and figure \ref{result:g_t10_total} shows same comparison for T40I10D100K dataset . The graphs shows that our algorithm works correctly for sparse dataset too. Figure \ref{result:g_chess_tree_construction_total}, figure \ref{result:g_chess_mining_total} and figure \ref{result:g_chess_total} shows tree construction time, mining time and total time for chess dataset. This one is dense dataset and the result is consistent, efficient and also scalable.
			\begin{figure}[h]
			\centering
				\input{result/mushroom/g_m_tree_construction_total}
			\caption{Total Tree Construction Time vs Minimum Support (\%) for Mushroom Dataset }
			\label{result:g_m_tree_construction_total}
			\end{figure}
			
			\begin{figure}[h]
			\centering
				\input{result/mushroom/g_m_mining_total}
			\caption{Total Tree Mining Time vs Minimum Support (\%) for Mushroom Dataset }
			\label{result:g_m_mining_total}
			\end{figure}
			\begin{figure}[h]
			\centering
				\input{result/mushroom/g_m_total}
			\caption{Running Time vs Minimum Support (\%) for Mushroom Dataset }
			\label{result:g_m_total}
			\end{figure}
			\begin{figure}[h]
			\centering
				\input{result/t10/g_t10_tree_construction_total}
			\caption{Total Tree Construction Time vs Minimum Support (\%) for T40I10D100K Dataset }
			\label{result:g_t10_tree_construction_total}
			\end{figure}
			
			\begin{figure}[h]
			\centering
				\input{result/t10/g_t10_mining_total}
			\caption{Total Tree Mining Time vs Minimum Support (\%) for T40I10D100K Dataset }
			\label{result:g_t10_mining_total}
			\end{figure}
			
			\begin{figure}[h]
			\centering
				\input{result/t10/g_t10_total}
			\caption{Running Time vs Minimum Support (\%) for T40I10D100K Dataset }
			\label{result:g_t10_total}
			\end{figure}
	
			\begin{figure}[h]
			\centering
				\input{result/chess/g_chess_tree_construction_total}
			\caption{Total Tree Construction Time vs Minimum Support (\%) for Chess Dataset }
			\label{result:g_chess_tree_construction_total}
			\end{figure}
			
			\begin{figure}[h]
			\centering
				\input{result/chess/g_chess_mining_total}
			\caption{Total Tree Mining Time vs Minimum Support (\%) for Chess Dataset }
			\label{result:g_chess_mining_total}
			\end{figure}
			
			\begin{figure}[h]
			\centering
				\input{result/chess/g_chess_total}
			\caption{Running Time vs Minimum Support (\%) for Chess Dataset }
			\label{result:g_chess_total}
			\end{figure}
			\begin{figure}[h]
			\centering
				\input{result/kosarak/g_k_tree_construction_total}
			\caption{Total Tree Construction Time vs Minimum Support (\%) for Kosarak Dataset }
			\label{result:g_k_tree_construction_total}
			\end{figure}
			
			\begin{figure}[h]
			\centering
				\input{result/kosarak/g_k_mining_total}
			\caption{Total Tree Mining Time vs Minimum Support (\%) for Kosarak Dataset }
			\label{result:g_k_mining_total}
			\end{figure}

			\begin{figure}[h]
			\centering
				\input{result/kosarak/g_k_total}
			\caption{Running Time vs Minimum Support (\%) for Kosarak Dataset }
			\label{result:g_k_total}
			\end{figure}
			
\clearpage
	\subsubsection{Memory Comparison}
		As our proposed \emph{US-tree} have capability to share nodes more than \emph{SUF-growth} , we get much more gain in memory. The experimental result also indicates that very clearly. Figure \ref{result:g_m_memory_node} shows the memory comparison on mushroom dataset. Mushroom is dense database so we get  much more gain in memory. The graph clearly shows that with the increase of total transaction in the tree gives the much more gain. For chess dataset the the compactness of tree is also very impressive as this dataset is also compact (figure \ref{result:g_chess_memory_node}) the Dense dataset have more scope to share nodes more. Figure \ref{result:g_t10_memory_node} also shows that in T40I10D100K database we also gain the memory optimization. As the database is sparse, we get the memory gain less then dense one.
			\begin{figure}[h]
			\centering
				\input{result/mushroom/g_m_memory_node}
			\caption{Avg Tree Node per window vs Frame Size for Mushroom Dataset }
			\label{result:g_m_memory_node}
			\end{figure}
			
			\begin{figure}[h]
			\centering
				\input{result/chess/g_chess_memory_node}
			\caption{Avg Tree Node per window vs Frame Size for Chess Dataset }
			\label{result:g_chess_memory_node}
			\end{figure}
			
			\begin{figure}[h]
				\input{result/t10/g_t10_memory_node}
			\caption{Avg Tree Node per window vs Frame Size for T40I10D100K Dataset }
			\label{result:g_t10_memory_node}
			\end{figure}
		
			\begin{figure}[h]
			\centering
				\input{result/kosarak/g_k_memory_node}
			\caption{Avg Node Count vs total transaction (in thousand) for Kosarak Dataset }
			\label{result:g_k_memory_node}
			\end{figure}